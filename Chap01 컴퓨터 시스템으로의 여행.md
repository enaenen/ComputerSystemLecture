# Chap01 컴퓨터 시스템으로의 여행

# 정보는 비트와 컨텍스트로 이루어진다

```java
#include <stdio.h>

int main(void)
{
	printf("hello world\n");
	return 0;
}
```

hello.c

hello 프로그램은 hello.c 라는 텍스트 파일로 저장된다

소스 프로그램은 0 또는 1로 되는 비트들의 연속이며, 바이트라는 8비트 단위로 구성된다. 각 바이트는 TEXT를 나타낸다.

대부분의 컴퓨터 시스템은 ASCII 표준을 사용하여 표시한다.
hello.c 프로그램은 연속된 바이트들로 파일에 저장된다.

각 바이트는 특정 문자에 대응되는 정수 값을 가진다.

```java
#   i   n   c  l   u   d   e 
35 105 110 99 108 117 100 101
```

아스키 문자들로만 이루어진 파일을 TEXT 파일이라고 한다. 다른 모든 파일들은 바이너리 파일이라고 한다.

모든 시스템 내부의 정보는 비트로 표시된다. 

# 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

```java
gcc -o hello hello.c
```

다음 과정을 거친다

1. hello.c (Source Program)
    
    PreProcessor 전처리 단계
    
2. hello.i
    
    Compiler 컴파일단계
    
3. hello.s →어셈블리어 파일
    
    Assembler 어셈블리단계
    
4. hello.o →기계어 인스트럭션으로 번역된 바이너리 파일
    
    Linker - printf.o  이미 컴파일된 별도의 목적파일인 printf.o와 통합작업을 수행
    
5. hello
    
    실행가능 목적파일(실행파일)로 메모리에 적재되어 시스템에 의해 실행
    

# 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석

```java
> ./hello
hello, world
>
```

shell에서 커맨드라인 인터프리터로 프롬프트를 출력하고 명령어 라인을 입력받아 명령을 실행한다.

# 하드웨어 구성

- 버스
    - 시스템 내를 관통하는 전기적 배선군
    - 컴포넌트 사이의 바이트 정보들을 전송
    - 32비트 환경→4바이트, 64비트 환경 → 8바이트 씩 데이터를 전송한다
    - 데이터의 전송 단위는 워드 word 다.
- 입출력 장치
    - 키보드
    - 마우스
    - 디스플레이
- 메인메모리
    - 물리적으로는 DRAM 칩으로 구성
    - 논리적으로는 메모리는 연속적인 바이트의 배열로, 고유의 주소(배열 index)를 가진다.
- 프로세서
    - CPU 또는 프로세서로 불린다
    - 메인 메모리에 저장된 인스트럭션을 해독(실행) 하는 엔진
    - 프로세서에는 워드 크기(4 or 8 byte)의 
    저장장치( 또는 레지스터)인 프로그램 카운터(PC)  가 있다.
        - PC는 메인 메모리의 기계어 인스트럭션을 가르킨다.
    - 전원이 공급되는 순간부터 끊어질때까지 PC가 가리키는 곳의 인스트럭션을 반복적으로 실행하고 PC값을 다음 인스트럭션 위치로 업데이트한다
    - ALU(수식 처리기), 메인메모리, 레지스터 파일 을 순환하면서 작업한다.
    
    ## 프로세서가 하는 일
    
    - 적재(Load) : 메인 메모리에서 레지스터 한 바이트 또는 워드를 이전 값에 덮어쓴다
    - 저장 (Store) : 레지스터에서 메인메모리로 값을 워드 단위로 덮어쓴다
    - 작업 (Operate) : 두 레지스터 값을 ALU로 복사 한 후 워드 단위로 수식연산을 수행한 뒤, 결과를 레지스터에 덮어쓴다.

# 프로그램의 실행

1. ./hello 를 입력
2. 쉘 프로그램은 각각 문자를 레지스터에 읽어온 후 레지스터에 저장
3. 엔터를 누르면 쉘은 명령 입력을 마쳤다는 것을 인지하고, 코드와 데이터를 복사하는 인스트럭션을 실행
⇒실행파일 hello를 디스크에서 메인 메모리로 로딩
4. 데이터 부분은 "hello, world\n" 스트링을 직접 메모리 접근(DMA)를 이용하여 프로세서를 거치지않고 디스크에서 메인 메모리로 이동
5. hello 목적파일의 코드와 데이터가 메모리에 적재된 후, 프로세서는 hello 프로그램의 main 루틴의 기계어 인스트럭션을 실행
6. 이 인스트럭션은 "hello, world \n" 스트링을 메모리로부터 레지스터 파일로 복사한 후 디스플레이 장치로 전송

# 캐시

hello 프로그램의 기계어 인스트럭션의 이동

하드디스크→메인메모리로 복사→프로세서로 복사

이 과정에서 실제작업을 느리게 하는 오버헤드가 발생

물리학의 법칙에 따라 큰 저장장치들은 작은 저장장치보다 느린속도를 가진다.

더 빠른 장치들은 느린 장치보다 비용이 많이 든다.

반도체 기술이 발달함에따라 프로세서-메모리 간 격차가 지속적으로 증가하고 있다. 메인메모리를 빠르게 하는 것보다 프로세서를 빨리 동작하도록 만드는게 더 쉽고 비용이 적다.

프로세서 - 메모리 간 격차를 대응하기 위해 시스템 설계자는 보다 작고 빠른 캐시 라고 부르는 저장장치를 고안하여, 프로세서가 단기간에 필요로할 가능성이 높은 정보를 임시로 저장할 목적으로 사용한다.

# 운영체제는 하드웨어를 관리한다

hello 프로그램이 메세지를 출력할 때, 프로그램이 키보드나 디스플레이, 디스크나 메인 메모리를 직접 액세스 하지 않는다. 오히려 운영체제가 제공하는 서비스를 활용한다.

응용프로그램이 하드웨어를 제어하려면 언제나 운영체제를 통해서 해야한다.

## 운영 체제의 목적

1. 제멋대로 동작하는 응용프로그램들이 하드웨어를 잘 못 사용하는 것을 막기 위해
2. 응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작하도록 하기 위해

# 프로세스

hello 같은 프로그램이 실행될 때 운영체제는 시스템에서 이 한 개의 프로그램만 실행되는 것 같은 착각을 제공해준다. 프로그램이 프로세서, 메인메모리, 입출력장치를 모두 독차지하는 느낌을 준다. → 프로세스라는 개념에 의해 만들어지는 환상이다.

프로세스는 실행 중인 프로그램에 대한 운영체제의 추상화다. 다수의 프로세스들은 동일한 시스템에서 동시에 실행될 수 있으며, 각 프로세스는 하드웨어를 배타적으로 사용하는 것처럼 느껴진다.

대부분의 시스템에서 프로세스를 실행할 CPU의 숫자보다 더 많은 프로세스들이 존재한다. 프로세서가 프로세스들을 바꿔주는 방식으로 한 개의 CPU가 다수의 프로세스를 동시에 실행하는 것처럼 보이게 해준다.

컨텍스트 스위칭을 통해 제어권을 다른 프로세스로 넘겨준다. 
hello 프로그램을 실행하라는 명령을 받으면, 쉘은 시스템 콜 이라는 특수 함수를 호출하여 운영체제로 제어권을 넘겨준다. 운영체제는 쉘의 컨텍스트를 저장하고 새로운 hello 프로세스와 컨텍스트를 생성하고 제어권을 새 hello 프로세스로 넘겨준다. hello 가 종료되면 운영체제는 쉘 프로세스의 컨텍스트를 복구시키고 제어권을 넘겨주면서 다음 명령 줄 입력을 기다린다.

## 커널

하나의 프로세스에서 다른 프로세스로의 전환은 운영체제 커널 Kernel에 의해 관리된다.

커널은 운영체제 코드의 일부분으로 메모리에 상주한다.

응용프로그램이 운영체제에 의한 어떤 작업을 요청하면, 컴퓨터는 파일 IO 같은 특정 시스템 콜을 실행해서 커널에 제어를 넘겨준다. 커널은 요청된 작업을 수행하고 응용프로그램으로 리턴한다.

커널은 별도의 프로세스가 아니다.

커널은 모든 프로세스를 관리하기 위해 시스템이 이용하는 크드와 자료구조의 집합이다.

 

# 스레드

프로세스는 다수의 스레드라고하는 실행 유닛으로 구성된다. 각각의 스레드는 해당 프로세스의 컨텍스트에서 실행되며, 동일한 코드와 전역 데이터를 공유한다.

프로세스들에서보다 스레드간 데이터의 공유가 더 쉽다는 점과 프로세스보다 더 효율적이다.

# 가상 메모리

가상메모리는 각 프로세스들이 메인 메모리를 전체를 독점적으로 사용하는 것 같은 환상을 제공하는 추상화이다.

- 프로그램 코드와 데이터
    
    코드는 모든 프로세스들이 같은 고정 주소에서 시작한다. 코드와 데이터 영역은 실행 가능 목적파일인 hello로 부터 직접 초기화 된다.
    
- 힙 heap
    
    런타임 힙
    
    크기가 고정되어있는 코드
    
    크기가 고정된 코드,데이터 영역과 달리 
    프로세스가 실행되면서 malloc이나 free를 호출하면서 런타임에 동적으로 크기가 늘었다 줄었다 한다.
    
- 공유 라이브러리
    
    C 표준 라이브러리, 수학 라이브러리와 같은 공유 라이브러리의 코드와 데이터를 저장하는 영역
    
- 스택 stack
    
    가상메모리 공간의 맨 위에
    
    컴파일러가 함수 호출을 구현하기위해 사용하는 사용자 스택이 존재
    
    실행되는 동안 동적으로 늘었다 줄었다 한다.
    
    함수 호출시 스택이 커지며 리턴될때 줄어든다.
    
- 커널 가상 메모리
    
    맨윗부분은 커널을 위해 예약된다. 이 영역의 내용을 읽거나 쓰는것이 금지된다.
    

# 파일

연속된 바이트들이다.

모든 입출력장치는 파일로 모델링한다.

시스템의 모든 IO들은 유닉스 I/O 라는 시스템 콜들을 이용해 파일을 읽고 쓰는 형태로 이루어진다.

# Amdahl 법칙

어떤 시스템의 한 부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는
개선되는 부분이 얼마나 중요한가와, 얼마나 빨라졌는가 에 관계된다는 것이다.

요지는 전체 시스템에서 개선되는 부분이 아무리 빨라졌다고(예를들면 2배) 하더라도,

개선된 부분이 전체 돌아가는 시스템에서 10%밖에 안되는 부분이라면 결국 작업속도는 1.05배 증가했다는 것이다,

![Untitled](Chap01%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%B2%E1%84%90%E1%85%A5%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%84%92%E1%85%A2%E1%86%BC%2079d292e227714956bcb9937c9dbe8dc0/Untitled.png)

p = 전체에서 개선될 수 있는 부분의 비율

k = 기존보다 개선되는 비율

요약

- 컴퓨터 시스템은 응용프로그램을 실행하기 위해 함께 동작하는 하드웨어와 시스템 소프트 웨어로 구성된다.
- 프로그램은 ASCII 문자로 시작해서, 컴파일러와 링커에 의해 바이너리 실행파일들로 번역된다.
- 컴퓨터는 대부분의 시간을 메모리, 입출력장치, CPU 레지스터 간 데이터를 복사하는데 사용된다.
따라서 저장장치간 계층구조를 형성해서 CPU 레지스터를 가장 상부로 하고 하부의 장치들은 상부 장치들을 위한 캐시 역할을 수행한다.
- 운영체제는 커널과 응용프로그램 사이에서 중간자 역할을 수행한다
- 운영체제는 세가지 근본적인 추상화를 제공한다
    1. 파일은 입출력 장치의 추상화이다
    2. 가상 메모리는 메인메모리와 디스크의 추상화다
    3. 프로세스는 프로세서, 메인 메모리, 입출력 장치의 추상화다
- 네트워크는 컴퓨터 시스템이 서로 통신할 수 있는 방법을 제공하며, 특정 시스템의 관점으로 볼 때, 네트워크는 단지 또 하나의 입출력장치다.